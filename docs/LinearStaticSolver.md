# LinearStaticSolver 仕様ドキュメント

最終更新: 2025-10-12

## 概要
`LinearStaticSolver` は 3D ビーム/フレーム要素の線形静解析を行うソルバーです。  
全体剛性マトリクスと荷重ベクトルを組み立て、境界条件を考慮したうえで自由自由度の連立一次方程式を解き、節点変位ベクトルを返します。

- 対応解析: 線形静解析（小変形）
- 要素: 3D ビーム（各節点6自由度）
- ライブラリ: MathNet.Numerics (線形代数)

## 単位と前提
- 単位系は N–mm 系を前提（推奨）
  - E: N/mm^2, 長さ: mm, 断面二次モーメント: mm^4, 荷重: N（点）、q: N/mm（等分布）
- 各節点の自由度（DOF）順序:
  - 0: UX, 1: UY, 2: UZ, 3: RX, 4: RY, 5: RZ
- 全体変位ベクトルのインデックス:
  - 節点 i（モデル内のリストインデックス）に対して、グローバルDOFは `i * 6 + dofLocal`（dofLocal は上表）  
  例: 節点 id=1 が Nodes リストのインデックス 1 に配置されている場合、節点2の Y 変位は `disp[1*6 + 1] == disp[7]`

- 座標系・符号規約:
  - グローバル座標は右手系。X 軸に沿う梁に対して、グローバル -Y 荷重は下向き。
  - 変位の符号は座標系に従う（下向きは UY < 0）。モーメント/回転は右手系。

## 実装概要

### 1) 剛性行列の組立 (AssembleGlobalStiffness)
- 各要素からローカル剛性 `keLocal (12x12)` を取得（Euler-Bernoulli ビーム: 軸, 2曲げ, ねじりを含む）。
- 要素座標変換行列 `T (12x12)` を用い、全体座標へ変換:
  - 変位写像: `d_local = T * d_global`
  - 力の釣合: `f_global = T^T * f_local`
  - 剛性の変換: `K_global_elem = T^T * keLocal * T`  ← 重要
- 要素が接続する節点の Nodes リスト内インデックスを求め、全体剛性 `globalK` にアセンブル
  - 注意: ノードIDとリストインデックスは一致しない可能性があるため、`FindIndex(n => n.Id == id)` で必ずマッピングする

### 2) 荷重ベクトルの組立 (AssembleGlobalLoad)
- 点荷重 (`PointLoad`)
  - 節点ID → Nodes リストインデックスを取得し、対応する6DOFに加算（モーメントも同）
  - `isLocal=false` の場合はグローバル座標系でそのまま加算。`isLocal=true` の場合は `f_global += T^T * f_local`
- 要素荷重 (`ElementLoad`)
  - ローカル座標系の等価節点荷重ベクトル `feLocal (12)` を生成（例: 等分布荷重 q の標準式）
  - 全体座標へ変換: `feGlobal = T^T * feLocal`
  - 接続節点の全体ベクトルへ加算

### 3) 境界条件と解法 (solve)
- サポート (`Support( fixDX..fixRZ )`) に基づき、固定DOF（既知=0）と自由DOFを分離
- 自由自由度サブマトリクス `Kff` と荷重 `Ff` を抽出
- ランク検査（SVD）で特異/劣条件を検出
  - `rank < n` のとき詳細なゼロモード診断（寄与の大きいDOFを例外メッセージに列挙）
- `Kff.Solve(Ff)` を解き、全体変位ベクトルへマッピング
- NaN/Inf 検査により異常を即時例外化

### 4) 支持ばね（任意, ペナルティ法）
- `Support.Stiffness[6]` が正値の場合、対応DOFの全体剛性対角要素へ加算
- 単位に注意（回転は N·mm/rad 相当）

### 5) 正則化（機構対策）
3D モデルでは、理想的なピン・ローラー支持だと剛体回転モードが残ることがあります。  
正則化を有効にすると、過度に小さい剛性や機構を抑え、数値安定性を改善します。

- 回転DOFの正則化
  - 代表回転剛性（中央値）を算出: `E*Iyy/L`, `E*Izz/L`, `G*J/L` の集合から中央値を `kref` とする
  - 対角加算: `kreg_rot = kref * RotationalRegularizationFactor`（推奨 1e-9〜1e-8）
  - 拘束されていない回転DOFにのみ加算
- 並進DOFの正則化
  - 代表軸剛性: `EA/L` を基準に `kreg_tr = (EA/L) * TranslationalRegularizationFactor` を対角加算
  - 物理剛性に対し十分小さく設定する（例: 1e-10〜1e-8）

### 6) 数値安定化と診断
- 小さな負固有値や丸め誤差による非対称化を抑制（対称化 `0.5*(K+K^T)` を内部適用可）
- 条件数の監視とログ出力（必要に応じ）
- 例外時に自由DOF、拘束DOF、想定ゼロモードを提示

## 追加仕様（最近の拡張点）
- DOF/荷重の座標変換の厳密化
  - 剛性: `K_g = T^T k_l T`
  - 荷重: `f_g = T^T f_l`、変位: `d_l = T d_g`
- 要素等価節点荷重のローカル→グローバル変換を統一
- 並進DOFの微小正則化の導入（機構 + 数値不安定の抑制）
- SVD によるランク検査と詳細診断メッセージ
- ノードIDとリストインデックスの厳密マッピング（ID != Index ケースの安全化）

## 検証（ユニットテストの想定結果）
- 片持ち梁・先端点荷重: δ = -P L^3 / (3 E Izz)（先端 UY）
- 単純支持梁・中央点荷重: δmax = -P L^3 / (48 E Izz)（中央 UY）
- 単純支持梁・全長等分布荷重: δmax = -5 q L^4 / (384 E Izz)（中央 UY）
- 複数要素離散化でも上記理論解と一致すること

## トラブルシューティング
- 符号が逆（下向き荷重で UY > 0 など）:
  - 点荷重の `isLocal` 取り扱いと座標変換（`T^T`）を確認
  - 要素ローカル軸（特にローカル Y/Z）とグローバル軸の対応を再確認
- 期待値の約 1/3 など明確な倍率ずれ:
  - 剛性変換式が `T * k * T^T` になっていないか（正しくは `T^T * k * T`）
  - 曲げ軸の慣性モーメントの取り違え（UY ↔ Izz, UZ ↔ Iyy）有無を確認
  - 中間節点の拘束条件が過剰/不足になっていないか（回転自由度の固定漏れや重複固定）
  - 正則化係数が大きすぎて実効剛性を汚染していないか
- 収束しない/特異行列:
  - 支持条件の不足（剛体モード）→ 正則化 or 拘束追加（例: 端部 RX の1点拘束）
  - ノードIDとインデックスの不一致で誤アセンブリ → `FindIndex` でのマッピング必須